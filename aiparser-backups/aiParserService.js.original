// AI Timetable Parser Service using OpenRouter.ai API

import { getOpenRouterApiKey } from "../utils/apiKeyManager";
import { tryParseJson } from "./jsonSanitizer";

/**
 * Helper function to clean and validate JSON before returning
 * @param {Object} jsonObject - The parsed JSON object
 * @param {number} textLength - Length of original text for heuristics
 * @returns {Object} - The cleaned and validated JSON object
 */
const cleanAndValidateJson = (jsonObject, textLength) => {
  try {
    // Ensure all required top-level properties exist
    if (!jsonObject.days || !Array.isArray(jsonObject.days)) {
      jsonObject.days = ["Day 1", "Day 2", "Day 3", "Day 4", "Day 5", "Day 6", "Day 7", "Day 8", "Day 9", "Day 10"];
    }

    if (!jsonObject.periods || !Array.isArray(jsonObject.periods) || jsonObject.periods.length < 3) {
      jsonObject.periods = [
        { name: "Period 1", startTime: "8:35am", endTime: "9:35am" },
        { name: "Period 2", startTime: "9:40am", endTime: "10:40am" },
        { name: "Period 3", startTime: "11:25am", endTime: "12:25pm" },
        { name: "Period 4", startTime: "12:30pm", endTime: "1:30pm" },
        { name: "Period 5", startTime: "2:25pm", endTime: "3:25pm" }
      ];
    }

    if (!jsonObject.classes || typeof jsonObject.classes !== 'object') {
      jsonObject.classes = {};
    }

    // Ensure each day has an entry in classes
    jsonObject.days.forEach(day => {
      if (!jsonObject.classes[day]) {
        jsonObject.classes[day] = {};
      }
      
      // Ensure each period exists for each day
      jsonObject.periods.forEach(period => {
        if (!jsonObject.classes[day][period.name]) {
          jsonObject.classes[day][period.name] = [];
        }
      });
    });

    // Return the validated object
    return redistributeClasses(jsonObject, textLength);
  } catch (error) {
    console.error("Error during JSON validation:", error);
    return createDefaultTimetableStructure();
  }
}

/**
 * Creates a default timetable structure as fallback
 * @returns {Object} - Default timetable structure
 */
const createDefaultTimetableStructure = () => {
  return {
    days: ["Day 1", "Day 2", "Day 3", "Day 4", "Day 5", "Day 6", "Day 7", "Day 8", "Day 9", "Day 10"],
    periods: [
      { name: "Period 1", startTime: "8:35am", endTime: "9:35am" },
      { name: "Period 2", startTime: "9:40am", endTime: "10:40am" },
      { name: "Period 3", startTime: "11:25am", endTime: "12:25pm" },
      { name: "Period 4", startTime: "12:30pm", endTime: "1:30pm" },
      { name: "Period 5", startTime: "2:25pm", endTime: "3:25pm" }
    ],
    classes: {
      "Day 1": {},
      "Day 2": {},
      "Day 3": {},
      "Day 4": {},
      "Day 5": {},
      "Day 6": {},
      "Day 7": {},
      "Day 8": {},
      "Day 9": {},
      "Day 10": {}
    }
  }
}

/**
 * Parse timetable text using OpenRouter.ai API with the optimized prompt
 * @param {string} timetableText - The timetable text to parse
 * @returns {Object} - Parsed timetable JSON object
 */
export const parseTimetableText = async (timetableText) => {
  try {
    // Store the length for heuristic use
    const timetableTextLength = timetableText ? timetableText.length : 0;
    
    // Get OpenRouter API key
    const apiKey = getOpenRouterApiKey();
    if (!apiKey) {
      throw new Error("OpenRouter API key not found");
    }

    // New optimized prompt for llama-3.3-8b model
    const systemPrompt = "You are an expert at extracting structured timetable data.\n\n" +
      "I will give you a school timetable in grid format (each column is a day, each row is a period). Convert it into this exact JSON format:\n\n" +
      "{\n" +
      "  \"days\": [\n" +
      "    \"Day 1\", \"Day 2\", \"Day 3\", \"Day 4\", \"Day 5\",\n" +
      "    \"Day 6\", \"Day 7\", \"Day 8\", \"Day 9\", \"Day 10\"\n" +
      "  ],\n" +
      "  \"periods\": [\n" +
      "    { \"name\": \"Period 1\", \"startTime\": \"8:35am\", \"endTime\": \"9:35am\" },\n" +
      "    { \"name\": \"Period 2\", \"startTime\": \"9:40am\", \"endTime\": \"10:40am\" },\n" +
      "    { \"name\": \"Period 3\", \"startTime\": \"11:25am\", \"endTime\": \"12:25pm\" },\n" +
      "    { \"name\": \"Period 4\", \"startTime\": \"12:30pm\", \"endTime\": \"1:30pm\" },\n" +
      "    { \"name\": \"Period 5\", \"startTime\": \"2:25pm\", \"endTime\": \"3:25pm\" }\n" +
      "  ],\n" +
      "  \"classes\": {\n" +
      "    \"Day 1\": {\n" +
      "      \"Period 1\": [...],\n" +
      "      \"Period 2\": [...],\n" +
      "      \"Period 3\": [...],\n" +
      "      \"Period 4\": [...],\n" +
      "      \"Period 5\": [...]\n" +
      "    },\n" +
      "    ...\n" +
      "    \"Day 10\": {\n" +
      "      ...\n" +
      "    }\n" +
      "  }\n" +
      "}\n\n" +
      "⚠️ DO NOT group all Period 1 classes from all days under `\"Period 1\"` in one place. That is incorrect.\n\n" +
      "✅ Instead, for each day, create a separate structure like:\n" +
      "\"Day 1\" → contains \"Period 1\" to \"Period 5\"\n" +
      "\"Day 2\" → contains \"Period 1\" to \"Period 5\"\n" +
      "...\n" +
      "\"Day 10\" → contains \"Period 1\" to \"Period 5\"\n\n" +
      "Each `\"Period\"` entry must include:\n" +
      "- \"subject\"\n" +
      "- \"code\"\n" +
      "- \"room\"\n" +
      "- \"teacher\"\n" +
      "- \"startTime\"\n" +
      "- \"endTime\"\n\n" +
      "If any period has no class, just leave it as an empty array (e.g., `\"Period 3\": []`).\n\n" +
      "Return only valid JSON. No markdown. No explanation.\n\n" +
      "Here is the timetable to convert:\n" +
      timetableText;

    // Call the OpenRouter API with streaming enabled
    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`,
        "HTTP-Referer": typeof window !== 'undefined' && window.location ? window.location.origin : 'https://premium-timetable.com', // Optional but recommended
        "X-Title": "Premium Timetable" // Optional but recommended
      },
      body: JSON.stringify({
        messages: [
          {
            role: "system",
            content: systemPrompt
          },
          {
            role: "user",
            content: ""  // Empty user message since the system prompt includes the timetable text
          }
        ],
        model: "meta-llama/llama-3.3-8b-instruct:free",  // Using the free tier of the newest model
        temperature: 0,  // Zero temperature for completely deterministic output
        stream: true,    // Enable streaming for faster responses
        max_tokens: 5900 // Reduced token limit to stay within API constraints
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      throw new Error(`OpenRouter API request failed: ${response.status} ${response.statusText} ${errorData ? JSON.stringify(errorData) : ''}`);
    }

    // Handle streaming response with the ReadableStream API
    let aiResponse = '';
    try {
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        // Decode the chunk
        const chunk = decoder.decode(value, { stream: true });
        
        // Parse the chunk which is formatted as "data: {...}\n\n"
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ") && line !== "data: [DONE]") {
            try {
              const data = JSON.parse(line.substring(6));
              const content = data.choices[0]?.delta?.content;
              if (content) {
                aiResponse += content;
                // Optional: log streaming content for debugging
                // console.log(content);
              }
            } catch (e) {
              // Skip invalid JSON in stream
              console.warn("Failed to parse streaming chunk:", e);
            }
          }
        }
      }
    } 
    catch (streamError) {
      console.error("Error during stream processing:", streamError);
      // If streaming fails, try to get the entire response at once
      try {
        const fullResponse = await response.json();
        if (fullResponse.choices && fullResponse.choices.length > 0) {
          aiResponse = fullResponse.choices[0].message.content || '';
        }
      } catch (fallbackError) {
        console.error("Fallback response handling failed:", fallbackError);
      }
    }
    
    if (!aiResponse) {
      throw new Error("No response from AI parser");
    }
    
    // Try to parse the response as JSON
    try {
      // Clean up any markdown or extra text that might be in the response
      const jsonStartIndex = aiResponse.indexOf('{');
      const jsonEndIndex = aiResponse.lastIndexOf('}') + 1;
      
      if (jsonStartIndex === -1 || jsonEndIndex === -1) {
        throw new Error("Could not find valid JSON in AI response");
      }
      
      let jsonContent = aiResponse.substring(jsonStartIndex, jsonEndIndex);
      console.log("Initial JSON extract:", jsonContent.substring(0, 100) + "...");
      
      // Use our robust JSON parser with sanitization
      const parsedResult = tryParseJson(jsonContent);
      console.log("Successfully parsed timetable structure with sanitization");
      
      // Validate the structure further
      return cleanAndValidateJson(parsedResult, timetableTextLength);
    } catch (error) {
      console.error("Error parsing AI response:", error);
      
      // If we have the raw response, we can try a more manual approach to extract structured data
      try {
        // Use a fallback parser using pattern matching to extract more specific information
        const fallbackParser = (text) => {
          const result = createDefaultTimetableStructure();
          
          // Simple heuristic parsing for class information
          const dayRegex = /Day\s+(\d+)/gi;
          const periodRegex = /Period\s+(\d+)/gi;
          const subjectRegex = /Subject:\s*([^,\n]+)/gi;
          const codeRegex = /Code:\s*([^,\n]+)/gi;
          const roomRegex = /Room:\s*([^,\n]+)/gi;
          const teacherRegex = /Teacher:\s*([^,\n]+)/gi;
          
          let dayMatch;
          let currentDay = "Day 1";
          let periodNum = 1;
          let currentPeriod = "Period 1";
          
          // Extract days
          while ((dayMatch = dayRegex.exec(text)) !== null) {
            const dayNum = dayMatch[1];
            const dayToUse = "Day " + dayNum;
            
            // Find periods for this day
            text.split(/\n/).forEach(line => {
              const periodMatch = periodRegex.exec(line);
              if (periodMatch) {
                periodNum = periodMatch[1];
                currentPeriod = "Period " + periodNum;
              }
              
              // Extract subject information
              const subjectMatch = subjectRegex.exec(line);
              if (subjectMatch) {
                const subjectName = subjectMatch[1].trim();
                const codeMatch = codeRegex.exec(line);
                const roomMatch = roomRegex.exec(line);
                const teacherMatch = teacherRegex.exec(line);
                
                // Get period data from default structure
                const periodData = result.periods.find(p => p.name === currentPeriod);
                
                if (periodData && subjectName) {
                  console.log("Adding subject " + subjectName + " to " + dayToUse + " " + currentPeriod);
                  
                  // Add class to the result
                  if (!result.classes[dayToUse][currentPeriod]) {
                    result.classes[dayToUse][currentPeriod] = [];
                  }
                  
                  result.classes[dayToUse][currentPeriod].push({
                    subject: subjectName,
                    code: codeMatch ? codeMatch[1].trim() : "",
                    room: roomMatch ? roomMatch[1].trim() : "",
                    teacher: teacherMatch ? teacherMatch[1].trim() : "",
                    startTime: periodData.startTime,
                    endTime: periodData.endTime
                  });
                }
              }
            });
          }
          
          return result;
        }
        
        return fallbackParser(aiResponse);
      } catch (fallbackError) {
        console.error("Fallback parsing failed:", fallbackError);
        throw new Error("AI parsing failed. " + (error.message || "Please try again or use another import method."));
      }
    }
  } catch (error) {
    console.error("Error in AI parsing service:", error);
    
    // Special handling for token limit errors
    if (error.message && (
      error.message.includes("tokens") || 
      error.message.includes("maximum context length") ||
      error.message.includes("token limit exceeded") ||
      error.message.includes("too large")
    )) {
      // Handle token limit error with more detailed logging
      console.log("Token limit exceeded, using fallback parser. Error:", error.message);
      console.log("Timetable text length:", timetableTextLength);
      return fallbackParser(timetableText, timetableTextLength);
    }
    
    // Also handle other common API errors that should trigger fallback parser
    if (error.message && (error.message.includes("429") || 
                         error.message.includes("503") || 
                         error.message.includes("500") ||
                         error.message.includes("timeout") ||
                         error.message.includes("rate limit"))) {
      console.log("API error, using fallback parser. Error:", error.message);
      return fallbackParser(timetableText, timetableTextLength);
    }
    
    throw new Error("AI parsing failed. " + (error.message || "Please try again or use another import method."));
  }
}

/**
 * Helper function to redistribute classes across days if they're all in Day 1
 * and ensure multiple classes per period are properly handled
 * @param {Object} jsonObject - The parsed JSON object
 * @param {number} textLength - Length of original text for heuristics
 * @returns {Object} - The JSON object with classes redistributed if necessary
 */
const redistributeClasses = (jsonObject, textLength) => {
  try {
    // Count classes per day to see if they're all in Day 1
    const classCounts = {};
    
    jsonObject.days.forEach(day => {
      classCounts[day] = 0;
      if (jsonObject.classes[day]) {
        Object.keys(jsonObject.classes[day]).forEach(period => {
          if (Array.isArray(jsonObject.classes[day][period])) {
            classCounts[day] += jsonObject.classes[day][period].length;
          }
        });
      }
    });
    
    // Total classes count
    const totalClasses = Object.values(classCounts).reduce((sum, count) => sum + count, 0);
    
    // Check if the distribution looks abnormal (most classes in Day 1 or too few classes overall)
    const day1Classes = classCounts["Day 1"] || 0;
    const needsRedistribution = totalClasses > 0 && 
      ((day1Classes / totalClasses > 0.8) || // Most classes are in Day 1
      (totalClasses < 5 && textLength > 500)); // Too few classes for amount of text
    
    if (needsRedistribution) {
      console.log("Detected suboptimal class distribution. Attempting to redistribute...");
      
      // For tabular data, try to extract column position from subject
      const dayColumnPattern = /^Day (\d+) column (\d+)$/i;
      let useColumnBasedDistribution = false;
      
      // Check if there are any classes with position metadata
      if (jsonObject.classes["Day 1"]) {
        Object.keys(jsonObject.classes["Day 1"]).forEach(period => {
          const classes = jsonObject.classes["Day 1"][period];
          if (Array.isArray(classes)) {
            classes.forEach(cls => {
              if (cls.metadata && cls.metadata.column) {
                useColumnBasedDistribution = true;
              }
              
              // Also check subject name for column hints
              if (cls.subject && dayColumnPattern.test(cls.subject)) {
                useColumnBasedDistribution = true;
              }
            });
          }
        });
      }
      
      if (useColumnBasedDistribution) {
        console.log("Using column-based redistribution for tabular data");
        const periodsByDay = {};
        
        // Initialize day containers
        jsonObject.days.forEach(day => {
          periodsByDay[day] = {};
          // Clear existing data
          if (jsonObject.classes[day]) {
            Object.keys(jsonObject.classes[day]).forEach(period => {
              jsonObject.classes[day][period] = [];
            });
          }
        });
        
        // Distribute based on column info
        Object.keys(jsonObject.classes["Day 1"]).forEach(period => {
          const classes = jsonObject.classes["Day 1"][period];
          if (Array.isArray(classes)) {
            classes.forEach(cls => {
              let targetDay = "Day 1"; // Default
              
              // Check metadata first
              if (cls.metadata && cls.metadata.column && cls.metadata.column > 0 && cls.metadata.column <= 10) {
                targetDay = `Day ${cls.metadata.column}`;
              }
              // Check subject for column hints
              else if (cls.subject) {
                const match = cls.subject.match(dayColumnPattern);
                if (match && match[1] && parseInt(match[1]) > 0 && parseInt(match[1]) <= 10) {
                  targetDay = `Day ${match[1]}`;
                }
              }
              
              // Now place in the correct day
              if (!jsonObject.classes[targetDay][period]) {
                jsonObject.classes[targetDay][period] = [];
              }
              
              // Make sure we're not adding a duplicate class
              const isDuplicate = jsonObject.classes[targetDay][period].some(existingClass => 
                existingClass.subject === cls.subject && 
                existingClass.room === cls.room && 
                existingClass.teacher === cls.teacher
              );
              
              if (!isDuplicate) {
                jsonObject.classes[targetDay][period].push(cls);
              }
            });
          }
        });
      } 
      else {
        // Create a pattern-based distribution
        // First, group classes by likely subject patterns
        const subjectGroups = {};
        
        if (jsonObject.classes["Day 1"]) {
          Object.keys(jsonObject.classes["Day 1"]).forEach(period => {
            const classes = jsonObject.classes["Day 1"][period];
            if (Array.isArray(classes)) {
              // If multiple classes already exist for this period in Day 1,
              // let's preserve them as a multi-class period (likely correct)
              if (classes.length > 1) {
                console.log(`Preserving ${classes.length} classes in Day 1 ${period} as a multi-class period`);
                // We leave these classes in Day 1, no redistribution needed
              } else {
                // For single classes, we do position-based or subject-based redistribution
                classes.forEach((cls, index) => {
                  // For tabular data, use position to determine day
                  if (index < 10) {
                    const targetDay = `Day ${index + 1}`;
                    
                    // Ensure the target day and period exist
                    if (!jsonObject.classes[targetDay]) {
                      jsonObject.classes[targetDay] = {};
                    }
                    if (!jsonObject.classes[targetDay][period]) {
                      jsonObject.classes[targetDay][period] = [];
                    }
                    
                    // Check for duplicates before adding
                    const isDuplicate = jsonObject.classes[targetDay][period].some(existingClass => 
                      existingClass.subject === cls.subject && 
                      existingClass.room === cls.room && 
                      existingClass.teacher === cls.teacher
                    );
                    
                    if (!isDuplicate) {
                      // Add to appropriate day (based on index position)
                      jsonObject.classes[targetDay][period].push(cls);
                      
                      // Clear from Day 1 since we moved it
                      jsonObject.classes["Day 1"][period] = 
                        jsonObject.classes["Day 1"][period].filter(c => c !== cls);
                    }
                  } else {
                    // Fall back to subject grouping for excess classes
                    const subjectKey = cls.subject?.toLowerCase() || "unknown";
                    if (!subjectGroups[subjectKey]) {
                      subjectGroups[subjectKey] = [];
                    }
                    subjectGroups[subjectKey].push({
                      period,
                      class: cls
                    });
                    
                    // Clear from Day 1 since we'll redistribute it
                    jsonObject.classes["Day 1"][period] = 
                      jsonObject.classes["Day 1"][period].filter(c => c !== cls);
                  }
                });
              }
            }
          });
        }
        
        // Distribute remaining subject groups across days
        // (only needed if we have excess classes beyond position-based distribution)
        const groupKeys = Object.keys(subjectGroups);
        if (groupKeys.length > 0) {
          groupKeys.forEach((groupKey, index) => {
            // Calculate which day this subject group should go to
            const targetDayIndex = (index % 10) + 1;
            const targetDay = `Day ${targetDayIndex}`;
            
            // Distribute this subject's classes to the target day
            subjectGroups[groupKey].forEach(item => {
              if (!jsonObject.classes[targetDay][item.period]) {
                jsonObject.classes[targetDay][item.period] = [];
              }
              
              // Check for duplicates before adding
              const isDuplicate = jsonObject.classes[targetDay][item.period].some(existingClass => 
                existingClass.subject === item.class.subject && 
                existingClass.room === item.class.room && 
                existingClass.teacher === item.class.teacher
              );
              
              if (!isDuplicate) {
                jsonObject.classes[targetDay][item.period].push(item.class);
              }
            });
          });
        }
      }
      
      console.log("Classes redistributed across days while preserving multi-class periods");
    }
    
    // Final pass: ensure we preserve multiple classes per period
    // Look for periods with multiple classes
    let multiClassCount = 0;
    jsonObject.days.forEach(day => {
      if (jsonObject.classes[day]) {
        Object.keys(jsonObject.classes[day]).forEach(period => {
          const classes = jsonObject.classes[day][period];
          if (Array.isArray(classes) && classes.length > 1) {
            multiClassCount++;
            
            // Deduplicate multiple classes in the same period
            const uniqueClasses = [];
            const seen = new Set();
            
            classes.forEach(cls => {
              // Create a unique key for this class
              const classKey = `${cls.subject}-${cls.room}-${cls.teacher}`;
              
              if (!seen.has(classKey)) {
                seen.add(classKey);
                uniqueClasses.push(cls);
              }
            });
            
            // Replace with deduplicated array
            jsonObject.classes[day][period] = uniqueClasses;
          }
        });
      }
    });
    
    if (multiClassCount > 0) {
      console.log(`Found and preserved ${multiClassCount} periods with multiple classes`);
    }
    
    return jsonObject;
  } catch (error) {
    console.error("Error during class redistribution:", error);
    return jsonObject;
  }
}

/**
 * Publicly exported fallback parser function
 * @param {string} timetableText - Raw text of the timetable to parse
 * @param {number} textLength - Length of original text for heuristics
 * @returns {Object} - Best attempt at parsing the timetable data
 */
export const fallbackParser = (timetableText, textLength) => {
  try {
    console.log("Using fallback parser for text:", timetableText.substring(0, 100) + "...");
    const textLen = textLength || timetableText.length;
    
    // Create a default timetable structure
    const result = createDefaultTimetableStructure();
    
    // Check if this looks like a tabular format timetable
    const lines = timetableText.trim().split('\n');
    const firstLine = lines[0].trim();
    
    // Check if first line has multiple "Day X" entries - indicating a table format
    const dayMatches = firstLine.match(/Day\s+\d+/g);
    const isTabularFormat = dayMatches && dayMatches.length > 1;
    
    if (isTabularFormat) {
      console.log("Detected tabular format timetable with", dayMatches.length, "day columns");
      
      // Parse the table format
      // First line contains day headers
      const dayHeaders = [];
      
      // Extract day headers (either tab or multiple space separated)
      let headers;
      if (firstLine.includes('\t')) {
        headers = firstLine.split('\t');
      } else {
        headers = firstLine.split(/\s{2,}/);
      }
      
      headers.forEach(header => {
        const dayMatch = header.match(/Day\s+(\d+)/i);
        if (dayMatch && dayMatch[1]) {
          dayHeaders.push({
            day: "Day " + dayMatch[1],
            index: parseInt(dayMatch[1])
          });
        }
      });
      
      if (dayHeaders.length < 2) {
        console.log("Could not detect enough day headers, falling back to standard parser");
      } else {              // We have a valid tabular format
              let currentPeriod = null;
              let currentPeriodStartTime = "";
              let currentPeriodEndTime = "";
              
              // Enhanced tabular format parser to handle multiple classes per period
              const parseTabularPeriod = (periodIndex, lines, startLineIndex, dayHeaders) => {
                // Period information
                const periodName = `Period ${periodIndex}`;
                const periodData = result.periods.find(p => p.name === periodName);
                if (!periodData) return startLineIndex;
                
                let lineIndex = startLineIndex;
                const classLines = [];
                
                // Continue until we hit another period or run out of lines
                while (lineIndex < lines.length) {
                  const line = lines[lineIndex].trim();
                  if (!line) {
                    lineIndex++;
                    continue;
                  }
                  
                  // Stop if we hit the next period marker
                  if (line.match(/^Period\s+\d+/i) || line.match(/^Tutorial/i)) {
                    break;
                  }
                  
                  // Add this line to our class data
                  classLines.push(line);
                  lineIndex++;
                }
                
                // Now parse the collected lines for each day
                if (classLines.length > 0) {
                  // We may have multiple rows of classes for this period (multiple classes per period)
                  for (let rowIndex = 0; rowIndex < classLines.length; rowIndex++) {
                    const classDataLine = classLines[rowIndex];
                    
                    // Split the line by common delimiters in tabular data
                    let classCells;
                    if (classDataLine.includes('\t')) {
                      classCells = classDataLine.split('\t');
                    } else if (classDataLine.includes('|')) {
                      classCells = classDataLine.split('|');
                    } else {
                      classCells = classDataLine.split(/\s{2,}/); // 2+ spaces
                    }
                    
                    // Process each cell as a potential class
                    classCells.forEach((cellContent, cellIndex) => {
                      cellContent = cellContent.trim();
                      if (!cellContent || cellContent.length < 2) return;
                      
                      // Find which day this cell corresponds to
                      if (cellIndex < dayHeaders.length) {
                        const dayInfo = dayHeaders[cellIndex];
                        const day = dayInfo.day;
                        
                        // Parse the class data
                        const subject = extractSubject(cellContent);
                        const code = extractCode(cellContent);
                        const room = extractRoom(cellContent);
                        const teacher = extractTeacher(cellContent);
                        
                        // Only add if we have a valid subject
                        if (subject && subject.length > 1) {
                          if (!result.classes[day][periodName]) {
                            result.classes[day][periodName] = [];
                          }
                          
                          // Check if this is a duplicate before adding
                          const isDuplicate = result.classes[day][periodName].some(
                            cls => cls.subject === subject && cls.room === room && cls.teacher === teacher
                          );
                          
                          if (!isDuplicate) {
                            result.classes[day][periodName].push({
                              subject: subject,
                              code: code || "",
                              room: room || "",
                              teacher: teacher || "",
                              startTime: currentPeriodStartTime || periodData.startTime,
                              endTime: currentPeriodEndTime || periodData.endTime
                            });
                          }
                        }
                      }
                    });
                  }
                }
                
                return lineIndex;
              }
              
              // Skip the first line as we already processed it
              let lineIndex = 1;
              while (lineIndex < lines.length) {
                const line = lines[lineIndex].trim();
                if (!line) {
                  lineIndex++;
                  continue;
                }                
                // Check if this is a period header
                const periodMatch = line.match(/^Period\s+(\d+)$|^Tutorial$/i);
                if (periodMatch) {
                  currentPeriod = periodMatch[0];
                  // Next line might have the period time
                  if (lineIndex + 1 < lines.length) {
                    const timeLine = lines[lineIndex + 1].trim();
                    const timeMatch = timeLine.match(/(\d+:\d+[ap]m)[–\-](\d+:\d+[ap]m)/i);
                    if (timeMatch) {
                      currentPeriodStartTime = timeMatch[1];
                      currentPeriodEndTime = timeMatch[2];
                      lineIndex++; // Skip the time line
                    }
                  }
                  
                  // Extract the period number
                  const periodNum = periodMatch[1] ? parseInt(periodMatch[1]) : 0;
                  if (periodNum > 0) {
                    // Process this period with our enhanced parser
                    lineIndex = parseTabularPeriod(periodNum, lines, lineIndex + 1, dayHeaders);
                    continue;
                  }
                  
                  lineIndex++;
                  continue;
                }
                
                // If we have a current period but didn't use the enhanced parser
                // (e.g., for tutorial periods), use the traditional approach
                if (currentPeriod) {
                  // Check if this line could be the start of subject data
                  const subjectDataStart = !line.match(/^Period|^Tutorial|^\d+:\d+[ap]m/i);
                  
                  if (subjectDataStart) {
                    // This could be subject data
                    // We need to collect multiple lines for each day's class in this period
                    const subjectLines = [];
                    let currentSubjectLine = 0;
                    
                    // Collect all lines that belong to this subject until we hit the next period
                    while (lineIndex < lines.length) {
                      const subjectLine = lines[lineIndex].trim();
                      
                      // Stop if we hit the next period or an empty line after subject data
                      if (subjectLine.match(/^Period\s+\d+$|^Tutorial$/i) || 
                          (!subjectLine && currentSubjectLine > 0)) {
                        lineIndex--;  // Back up so we process this line in the outer loop
                        break;
                      }
                      
                      if (subjectLine) {
                        // Add to our collection of subject lines
                        if (subjectLines.length <= currentSubjectLine) {
                          subjectLines.push([]);
                        }
                        subjectLines[currentSubjectLine].push(subjectLine);
                        
                        // If we have collected enough lines per subject or hit a time line
                        // move to the next subject line
                        if (subjectLine.match(/^\d+:\d+[ap]m[–\-]\d+:\d+[ap]m$/i) ||
                            subjectLine.match(/(Mr|Mrs|Ms|Dr|Miss)\.?\s+[A-Za-z\s]+/i)) {
                          currentSubjectLine++;
                        }
                      }
                      
                      lineIndex++;
                    }
                    
                    // Now process each subject line set for each day
                    const periodData = result.periods.find(p => {
                      const periodName = periodMatch && periodMatch[1] ? 
                        "Period " + periodMatch[1] : periodMatch[0];
                      return p.name === periodName;
                    });
                    
                    // Use collected subject lines to populate classes for each day
                    if (periodData && subjectLines.length > 0) {
                      // For each day in our headers
                      dayHeaders.forEach((dayHeader, dayIndex) => {
                        if (dayIndex < subjectLines.length) {
                          const daySubjectLines = subjectLines[dayIndex].join(' ');
                          
                          // Extract subject, code, room, and teacher
                          const subject = extractSubject(daySubjectLines);
                          const code = extractCode(daySubjectLines);
                          const room = extractRoom(daySubjectLines);
                          const teacher = extractTeacher(daySubjectLines);
                          
                          // Only add if we have a valid subject
                          if (subject && subject.length > 1) {
                            if (!result.classes[dayHeader.day][periodData.name]) {
                              result.classes[dayHeader.day][periodData.name] = [];
                            }
                            
                            // Check for duplicates
                            const isDuplicate = result.classes[dayHeader.day][periodData.name].some(
                              cls => cls.subject === subject && cls.room === room && cls.teacher === teacher
                            );
                            
                            if (!isDuplicate) {
                              result.classes[dayHeader.day][periodData.name].push({
                                subject: subject,
                                code: code || "",
                                room: room || "",
                                teacher: teacher || "",
                                startTime: currentPeriodStartTime || periodData.startTime,
                                endTime: currentPeriodEndTime || periodData.endTime
                              });
                            }
                          }
                        }
                      });
                    }
                    
                    continue;
                  }
                }
                
                lineIndex++;
              }
        }
        
        // If we got here with tabular parsing, return the result
        let totalClassesFound = 0;
        Object.keys(result.classes).forEach(day => {
          Object.keys(result.classes[day]).forEach(period => {
            totalClassesFound += result.classes[day][period].length;
          });
        });
        
        if (totalClassesFound > 0) {
          console.log(`Successfully parsed ${totalClassesFound} classes from tabular format`);
          return redistributeClasses(result, textLen);
        }
      }
    }
      
    // If we get here, either it's not a tabular format or tabular parsing failed
    // Fall back to the regular line-by-line parser
    try {
      console.log("Using standard line-by-line parser");
      let currentDay = "Day 1";
      let currentPeriod = "Period 1";
    
      // Process each line of the timetable text
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Try to extract day information - expanded patterns
        const dayMatch = line.match(/day\s*(\d+)|d\s*(\d+)|day\s*(\d+)\s*[\-:]/i);
        if (dayMatch) {
          const dayNum = dayMatch[1] || dayMatch[2] || dayMatch[3];
          currentDay = "Day " + dayNum;
          continue;
        }
        
        // Try date-based day correlation (look for dates that might indicate school days)
        const dateMatch = line.match(/(\d{1,2})[\/-](\d{1,2})(?:[\/-](\d{2,4}))?/);
        if (dateMatch && !line.match(/^\d+$/)) { // Avoid matching pure numbers
          // Store the detected date info and correlate to a day
          const dayIndex = (parseInt(dateMatch[1]) + parseInt(dateMatch[2])) % 10;
          const dayNumber = dayIndex === 0 ? 10 : dayIndex;
          currentDay = "Day " + dayNumber;
          continue;
        }
        
        // Try to extract period information
        const periodMatch = line.match(/period\s*(\d+)|^p(\d+)|^tut(orial)?/i);
        if (periodMatch) {
          if (periodMatch[0].match(/^tut(orial)?/i)) {
            currentPeriod = "Tutorial";
          } else {
            const periodNum = periodMatch[1] || periodMatch[2];
            currentPeriod = "Period " + periodNum;
          }
          continue;
        }
        
        // Try to extract subject information
        if (line.length > 3 && !line.match(/^(day|period|tutorial)/i)) {
          // Extract subject name - typically not just numbers
          const subject = extractSubject(line);
          const code = extractCode(line);
          const room = extractRoom(line);
          const teacher = extractTeacher(line);
          
          // Add the subject to the timetable if we have enough information
          if (subject && subject.length > 2) {
            // Find the period data
            const periodData = result.periods.find(p => p.name === currentPeriod);
            
            if (periodData && result.classes[currentDay] && result.classes[currentDay][currentPeriod]) {
              // Check if we already have a class with the same subject in this period
              const existingClassIndex = result.classes[currentDay][currentPeriod].findIndex(
                cls => cls.subject === subject
              );
              
              // We have multiple classes for the same subject, so this could be
              // a class that's offered to multiple groups during the same period
              if (existingClassIndex >= 0) {
                // If the teacher or room is different, it's a different class offering
                const existingClass = result.classes[currentDay][currentPeriod][existingClassIndex];
                if (teacher && teacher !== existingClass.teacher || 
                    room && room !== existingClass.room) {
                  // Add as a new class in the same period
                  result.classes[currentDay][currentPeriod].push({
                    subject: subject,
                    code: code || "",
                    room: room || "",
                    teacher: teacher || "",
                    startTime: periodData.startTime,
                    endTime: periodData.endTime
                  });
                }
              } else {
                // Add the class
                result.classes[currentDay][currentPeriod].push({
                  subject: subject,
                  code: code || "",
                  room: room || "",
                  teacher: teacher || "",
                  startTime: periodData.startTime,
                  endTime: periodData.endTime
                });
              }
            }
          }
        }
      }
      
      // Apply final redistribution and validation
      return redistributeClasses(result, textLen);
    } catch (innerError) {
      console.error("Error in line-by-line parser:", innerError);
      // Fall through to outer try-catch
    }
  
    // Apply final redistribution and validation
    return redistributeClasses(result, textLen);
  } catch (error) {
    console.error("Error in fallback parser:", error);
    return createDefaultTimetableStructure();
  }
}

// Helper functions for extraction
function extractSubject(text) {
  // Remove code in parentheses
  let subject = text.replace(/\([^)]+\)/g, '').trim();
  
  // Remove room code patterns
  subject = subject.replace(/\b[A-Z]\s*\d+\b/g, '').trim();
  
  // Remove teacher patterns
  subject = subject.replace(/(Mr|Mrs|Ms|Dr|Miss)\.?\s+[A-Za-z\s]+/ig, '').trim();
  
  return subject;
}

function extractCode(text) {
  const codeMatch = text.match(/\(([A-Za-z0-9]+)\)/) || 
                   text.match(/\b([A-Z0-9]{5,})\b/);
  return codeMatch ? codeMatch[1] : "";
}

function extractRoom(text) {
  const roomMatch = text.match(/\b([A-Z])\s*(\d+)\b/);
  if (roomMatch) {
    return roomMatch[1] + " " + roomMatch[2];
  }
  return "";
}

function extractTeacher(text) {
  const teacherMatch = text.match(/(Mr|Mrs|Ms|Dr|Miss)\.?\s+[A-Za-z\s]+/i);
  return teacherMatch ? teacherMatch[0] : "";
}

// Also export parseWithAI as an alias for parseTimetableText for compatibility
export const parseWithAI = parseTimetableText;
